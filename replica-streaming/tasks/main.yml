# (c) Copyright 2016 DataNexus Inc.  All Rights Reserved. 
#
# streaming tasks for the replica
---
#- set_fact: master_server={{ hostvars[inventory_hostname].groups.tag_Role_master[0] }}
#  when: hostvars[inventory_hostname].groups.tag_Role_master[0] is defined
- name: finding postgresql-replica IP
  local_action: shell AWS_PROFILE=iagcl common-utils/inventory/aws/ec2
  register: ec2_output
- name: finding postgresql-master IP
  local_action: shell NO_PROXY=auiag.corp common-utils/inventory/osp/openstack
  register: osp_output
- set_fact:
    ec2_output_json: "{{ ec2_output.stdout | from_json }}"
- set_fact: 
    osp_output_json: "{{ osp_output.stdout | from_json }}"
- set_fact:
    ec2_cloud_nodes: "{{ ec2_output_json | json_query('tag_Cloud_aws') }}"
    ec2_tenant_nodes: "{{ ec2_output_json | json_query('tag_Tenant_' + tenant) }}"
    ec2_project_nodes: "{{ ec2_output_json | json_query('tag_Project_' + project) }}"
    ec2_domain_nodes: "{{ ec2_output_json | json_query('tag_Domain_ProdA') }}"
    ec2_application_nodes: "{{ ec2_output_json | json_query('tag_Application_' + application) }}"
    ec2_role_nodes: "{{ ec2_output_json | json_query('tag_Role_replica') }}"
- set_fact:
    postgresql_replica_nodes: "{{ ec2_cloud_nodes | intersect(ec2_tenant_nodes) | intersect(ec2_project_nodes) | intersect(ec2_domain_nodes) | intersect(ec2_application_nodes) | intersect(ec2_role_nodes) }}"
- set_fact:
    osp_cloud_nodes: "{{ (osp_output_json | json_query('[\"meta-Cloud_osp\"]')).0 }}"
    osp_tenant_nodes: "{{ (osp_output_json | json_query('[\"meta-Tenant_' + tenant + '\"]')).0 }}"
    osp_project_nodes: "{{ (osp_output_json | json_query('[\"meta-Project_' + project + '\"]')).0 }}"
    osp_domain_nodes: "{{ (osp_output_json | json_query('[\"meta-Domain_production\"]')).0 }}"
    osp_application_nodes: "{{ (osp_output_json | json_query('[\"meta-Application_' + application + '\"]')).0 }}"
    osp_role_nodes: "{{ (osp_output_json | json_query('[\"meta-Role_master\"]')).0 }}"            
- set_fact:
    postgresql_master_nodes: "{{ osp_cloud_nodes | intersect(osp_tenant_nodes) | intersect(osp_project_nodes) | intersect(osp_domain_nodes) | intersect(osp_application_nodes) | intersect(osp_role_nodes) }}"

#      - debug: msg="IP is {{ (osp_output_json | json_query('_meta.hostvars.["6244096e-75c8-4cbe-8b52-6c2007882aa0"]')).0.ansible_ssh_host }}"

- name: adding master to dynamic host list
  add_host:
  #  hostname: "{{ (osp_output_json | json_query('_meta.hostvars.[\"' + item + '\"]')).0.ansible_ssh_host }}"
    hostname: "{{ item }}"
    ansible_ssh_private_key_file: /Users/christopher/Documents/IAG/CustomerLabs/DataEngineering/DataNexus_Platform/Source/customer-demo/osp-melbourne-1-postgresql-demo-production-private-key.pem
    ansible_user: cloud-user
    groups: "{{ application }}-master,osp-nodes"
  with_items: "{{ postgresql_master_nodes }}"
#        when: postgresql_master_nodes is defined
- name: adding replica to dynamic host list
  add_host:
    hostname: "{{ item }}"
    ansible_ssh_private_key_file: /Users/christopher/Documents/IAG/CustomerLabs/DataEngineering/DataNexus_Platform/Source/customer-demo/aws-ap-southeast-2-postgresql-demo-ProdA-private-key.pem
    ansible_user: centos
    groups: "{{ application }}-replica,aws-nodes"
  with_items: "{{ postgresql_replica_nodes }}"

#- debug: msg="{{ postgresql_replica_nodes }}"
- set_fact: master_server={{ postgresql_master_nodes }}
  when: postgresql_master_nodes is defined

- block:
    - name: Preserve postgresql.conf
      command: /bin/cp {{ postgresql_config_path }}/postgresql.conf /tmp
      become_user: "{{ postgresql_user }}"

    - name: Remove data directory in preparation for streaming
      file:
        path: "{{ postgresql_data_dir }}"  
        state: absent

    - name: Ensure PostgreSQL data directory exists.
      file:
        path: "{{ postgresql_data_dir }}"
        owner: "{{ postgresql_user }}"
        group: "{{ postgresql_group }}"
        state: directory
        mode: 0700
    
    - name: ensure PostgreSQL preferences directory exists
      file:
        path: "{{ postgresql_home_dir }}/.postgresql"
        owner: "{{ postgresql_user }}"
        group: "{{ postgresql_group }}"
        state: directory
        mode: 0700      
    
    - name: check if SSL keys exist
      stat:
        path: "{{ postgresql_home_dir }}/.postgresql/postgresql.key"
      register: pghome_key 
      
    - name: create SSL certs and keys
      command: /bin/openssl req -nodes -newkey rsa:2048 -keyout {{ postgresql_home_dir }}/.postgresql/postgresql.key -out {{ postgresql_home_dir }}/postgresql.csr -subj "/C=US/ST=CO/L=Denver/O=DataNexus/CN=replicator"
      become_user: "{{ postgresql_user }}"
      when: not pghome_key.stat.exists

    - name: upload the master signing cert
      copy: 
        src: /tmp/root.crt
        dest: "{{ postgresql_home_dir }}/.postgresql/root.crt"
        owner: "{{ postgresql_user }}"
        group: "{{ postgresql_group }}"
        mode: 0400
    
    - name: upload the master server key
      copy: 
        src: /tmp/server.key
        dest: /var/lib/pgsql/server.key
        owner: "{{ postgresql_user }}"
        group: "{{ postgresql_group }}"
        mode: 0400
        
    - name: sign replica key
      command: /bin/openssl x509 -req -in {{ postgresql_home_dir }}/postgresql.csr -CA "{{ postgresql_home_dir }}/.postgresql/root.crt" -CAkey {{ postgresql_home_dir }}/server.key -out {{ postgresql_home_dir }}/.postgresql/postgresql.crt -CAcreateserial
      become_user: "{{ postgresql_user }}"

    - name: ensure replica key permissions
      file:
        path: "{{ postgresql_home_dir }}/.postgresql/postgresql.key"
        owner: "{{ postgresql_user }}"
        group: "{{ postgresql_group }}"
        mode: 0400
        
    - name: copy initial database
      command: /bin/pg_basebackup -h {{ hostvars[item].ansible_eth1.ipv4.address }} -D {{ postgresql_data_dir }} -U replicator -v -P --xlog-method=stream
      become_user: "{{ postgresql_user }}"
      with_items: "{{ master_server }}"

    - name: Restore postgresql.conf
      command: /bin/cp /tmp/postgresql.conf {{ postgresql_config_path }}
      become_user: "{{ postgresql_user }}"
   
    - name: build recovery file
      blockinfile:
        name: "{{ postgresql_config_path }}/recovery.conf"
        mode: 0600
        create: yes
        block: |
          standby_mode = 'on'
          primary_conninfo = 'host={{ hostvars[item].ansible_eth1.ipv4.address }} port=5432 user=replicator sslmode=require sslcert={{ postgresql_home_dir }}/.postgresql/postgresql.crt sslkey={{ postgresql_home_dir }}/.postgresql/postgresql.key'
          trigger_file = '/tmp/postgresql.trigger'
      become_user: "{{ postgresql_user }}"
      with_items: "{{ master_server }}"

    - name: Fix SE Linux labels on {{ postgresql_data_dir }}
      command: /usr/sbin/fixfiles -F restore "{{ postgresql_data_dir }}"

    - name: configure write ahead log for streaming
      lineinfile:
        dest: "{{ postgresql_config_path }}/postgresql.conf"
        regexp: "^#wal_level"
        backrefs: yes
        line: "wal_level = hot_standby\t\t\t# minimal, archive, or hot_standby"
      notify: restart postgresql

    - name: turn on hot standby
      lineinfile:
        dest: "{{ postgresql_config_path }}/postgresql.conf"
        regexp: "^#hot_standby ="
        backrefs: yes
        line: "hot_standby = on\t\t\t# \"on\" allows queries during recovery"
      notify: restart postgresql

    - name: configure write ahead log senders
      lineinfile:
        dest: "{{ postgresql_config_path }}/postgresql.conf"
        regexp: "^#max_wal_senders"
        backrefs: yes
        line: "max_wal_senders = 3\t\t# max number of walsender processes"
      notify: restart postgresql

    - name: configure checkpoint segments
      lineinfile:
        dest: "{{ postgresql_config_path }}/postgresql.conf"
        regexp: "^#checkpoint_segments"
        backrefs: yes
        line: "checkpoint_segments = 8\t\t\t# logfile segments, min 1, 16MB each"
      notify: restart postgresql

    - name: configure write ahead log keep segments
      lineinfile:
        dest: "{{ postgresql_config_path }}/postgresql.conf"
        regexp: "^#wal_keep_segments"
        backrefs: yes
        line: "wal_keep_segments = 8\t\t# in logfile segments, 16MB each; 0 disables"
      notify: restart postgresql    
  when: master_server is defined
  become: true